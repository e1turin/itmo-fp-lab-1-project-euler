# Лабораторная работа №1

Цель: освоить базовые приёмы и абстракции функционального программирования:
функции, поток управления и поток данных, сопоставление с образцом, рекурсия,
свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы вам предлагается решить несколько задач [проекта
Эйлер](https://projecteuler.net/archives). Список задач -- ваш вариант.

Для каждой проблемы должно быть представлено несколько решений:

1. монолитные реализации с использованием:
   - хвостовой рекурсии;
   - рекурсии (вариант с хвостовой рекурсией не является примером рекурсии);
2. модульной реализации, где явно разделена генерация последовательности,
   фильтрация и свёртка (должны использоваться функции reduce/fold, filter и
   аналогичные);
3. генерация последовательности при помощи отображения (map);
4. работа со спец. синтаксисом для циклов (где применимо);
5. работа с бесконечными списками для языков, поддерживающих ленивые коллекции
   или итераторы как часть языка (к примеру Haskell, Clojure);
6. реализация на любом удобном для вас традиционном языке программирования для
   сравнения.

Требуется использовать идиоматичный для технологии стиль программирования.

Содержание отчёта:

- титульный лист;
- описание проблемы;
- ключевые элементы реализации с минимальными комментариями;
- выводы (отзыв об использованных приёмах программирования).

Примечания:

- необходимо понимание разницы между ленивыми коллекциями и итераторами;
- нужно знать особенности используемой технологии и того, как работают
  использованные вами приёмы.

- - -

# Комментарии

Для демонстрации работы с бесконечными структурами данных можно представить генератор "путей в треугольнике" это порядка $2^15$ комбинаций, что условно можно считать бесконечностью. И чтобы не все данные хранить в памяти, можно хранить лишь максимум из всех предыдущих вариантов путей. 

В 13 задаче не ясно как применить map, можно представить рекурсивное отображение списка в список сумм симметричных центру эллементов для целого, потом половины, четверти ... списка чисел, Но это будет рекурсия, которая более наглядно реализована. Наивную рекурсию приходится лечить `assert_total`, потому что компилятор не может проверить ее тотальность (ведь она правда может не завершиться, если передать бесконечный список). Ну, и бесконечную последовательность тут особенно сложно представить, т.к. 100 << ♾, даже не как в 18 задаче.
